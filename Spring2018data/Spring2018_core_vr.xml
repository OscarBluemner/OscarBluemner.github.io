<?xml version="1.0" encoding="UTF-8"?>
<krpano>
  <!-- Global variables used by actions and plugins -->
  <krpano 
        tour_soundson="true" 
        tour_soundsvolume="100" 
        tour_autotourenabled="false"
        tour_autorotateenabled="false"
        tour_controlmodemousetype="drag"
        tour_controlmodetouchtype="drag"
        tour_fullscreen="false"
        tour_displaymap="false"
        tour_displaythumbnails="true"
        tour_displayfloorplan="false"
        tour_displayinfo="false"
        tour_displayspots="true"
        tour_displaycontrols="true"
        tour_language="en" />
  <krpano tour_gyroscopedevices="true" devices="no-desktop.and.html5" />
  <krpano tour_vrdevices="true" devices="html5" />
  <krpano videos_sounds_path="%FIRSTXML%" devices="html5" />
  <krpano videos_sounds_path="%SWFPATH%" devices="flash" />
  <krpano projection_current_params="view.fisheyefovlink=0.5&amp;view.architectural=0.0&amp;view.pannini=0.0&amp;view.fisheye=0.0&amp;view.stereographic=false" />


  <krpano vrtourdevice.desktop="desktop" vrtourdevice.tablet="tablet" vrtourdevice.mobile="mobile" />
  <krpano vrtourdevicescale.desktop="1.0" vrtourdevicescale.tablet="1.0" vrtourdevicescale.mobile="2.0" />
  <action name="vrtourcurrentscale" autorun="preinit">
    mul(stagescale,get(vrtourdevicescale));
  </action>

  <!-- Control Mode Management -->
  <control mouse="drag" touch="drag" />
  <action name="setControlModeDragTo">setControlMode(drag);</action>
  <action name="setControlModeMoveTo">setControlMode(moveto);</action>
  <action name="setControlMode">
    if (device.desktop,
      set(control.mouse, %1);
      set(tour_controlmodemousetype, %1);
    ,
      set(control.touch, %1);
      set(tour_controlmodetouchtype, %1);
    );
    events.dispatch(oncontrolmodechanged);
  </action>



  <!-- Tour Messages -->
  <action name="getmessage">
    txtadd(real_message_id, get(tour_language), "_", %2);
    set(%1, get(data[get(real_message_id)].content));
  </action>

  <!-- Hide / Show Hotspots -->
  <action name="hideHotspots">
    set(tour_displayspots, false);
    set(nb_spots, get(hotspot.count));
    if (nb_spots != 0, hidepanospotsaction(); );
    events.dispatch(hotspots_visibility_changed);
  </action>
  <action name="showHotspots">
    set(tour_displayspots, true);
    set(nb_spots, get(hotspot.count));
    if (nb_spots != 0, showpanospotsaction(); );
    events.dispatch(hotspots_visibility_changed);
  </action>

  <events name="hideShowHotspotsOnNewPanoEvent" onPanoStart="hideShowHotspotsOnNewPanoAction" keep="true"/>
  <action name="hideShowHotspotsOnNewPanoAction">
    set(nb_spots, get(hotspot.count));
    if (nb_spots != 0,
      if (tour_displayspots, showpanospotsaction(); , hidepanospotsaction(); );
    );
  </action>



  <action name="startbehavioursxmlcompleteaction">
    events.dispatch(onPanoStart);
  </action>









  <krpano panovideospotsstate="false" />
  <krpano panolivepanospotsstate="false" />
  <events name="panoVideosSpotsStateEvent" onTourStart="set(panovideospotsstate, true);set(panolivepanospotsstate, true);" keep="true" />

  <krpano ptblendmode="BLEND(1.0, easeInCubic)" />
  <action name="mainloadsceneStartup">
    loadscene(%1, get(projection_current_params), NOPREVIEW|MERGE);
  </action>
  <action name="mainloadscene">
    if (xml.scene != %1,

      interruptAnimation();

      for(set(scenei,0), scenei LT scene.count, inc(scenei),if(scene[get(scenei)].name == %1,
      


      loadscene(%1, get(projection_current_params), NOPREVIEW|MERGE|KEEPVIEW|KEEPMOVING, get(ptblendmode));


      ););

    );
  </action>

  <!-- Load Previous Scene -->
  <action name="loadPreviousScene">
    if (%1 != findscene, sub(sceneprevnexti, scene.count, 1));
    copy(scenenamei, scene[get(sceneprevnexti)].name);
    dec(sceneprevnexti);
    if (scenenamei == xml.scene,
      if (sceneprevnexti GE 0,
        mainloadscene(get(scene[get(sceneprevnexti)].name));
       ,
        sub(lasti, scene.count, 1);
        mainloadscene(get(scene[get(lasti)].name));
      );
     ,
      if(sceneprevnexti GE 0, loadPreviousScene(findscene));
    );
  </action>

  <!-- Load Next Scene -->
  <action name="loadNextScene">
    if (%1 != findscene, set(sceneprevnexti,0));
    copy(scenenamei, scene[get(sceneprevnexti)].name);
    inc(sceneprevnexti);
    if (scenenamei == xml.scene,
      if (sceneprevnexti LT scene.count,
        mainloadscene(get(scene[get(sceneprevnexti)].name));
       ,
        mainloadscene(get(scene[0].name)); );
     ,
      if(sceneprevnexti LT scene.count, loadNextScene(findscene));
    );
  </action>


  <!-- AUTOROTATION -->
  <autorotate enabled="false"/>
  <krpano tour_autorotation_pausecounter="0"/>
  <krpano tour_autorotation_pauseplugin="0"/>
  <krpano tour_autorotation_openatstartplugin="0"/>
  <action name="startautorotation">
    if(tour_autorotation_pausecounter LE 0,
      set(tour_autorotateenabled, true );

      invalidatescreen();
      set(autorotate.enabled, true);
      set(tour_autorotation_pausecounter, 0);
      events.dispatch(onstartautorotation);

      if(tour_autotourenabled,
        resetautotourvariables();
      );
    );
  </action>
  <action name="stopautorotation">
    set(tour_autorotateenabled, false);
    set(autorotate.enabled, false);
    events.dispatch(onstopautorotation);

    if(tour_autotourenabled,
      stopautotourtimer();
    );
  </action>
  <action name="pauseautorotation">
    if(%1 == forceplugin,
      inc(tour_autorotation_pauseplugin);
    );
    inc(tour_autorotation_pausecounter);
    if(tour_autorotateenabled,
      set(autorotate.enabled, false);
      events.dispatch(onpauseautorotation);

      if(tour_autotourenabled AND useautotourdelay == false,
        stopautotourtimer();
      );
    );
  </action>
  <action name="resumeautorotation">
    if(%1 == forceplugin,
      if (tour_autorotation_pauseplugin GT 0,
        dec(tour_autorotation_pauseplugin);
      );
    );
    if (tour_autorotation_pausecounter GE 0,
      if(%1 != forceresume,
        if ((tour_autorotation_pausecounter GT 0) AND (tour_autorotation_pausecounter GT tour_autorotation_pauseplugin),
         dec(tour_autorotation_pausecounter);
        );
      );
    );
    if(tour_autorotateenabled,
      if(tour_autorotation_pausecounter == 0,
        if(%1 != forceresume,
          set(autorotate.enabled, true);
          events.dispatch(onresumeautorotation);

          if(tour_autotourenabled,
            resetautotourvariables();
          );
        );
      );
    ,
      if(%1 != forceresume,
        if(%1 != forceplugin,
          if(%1 != forcehotspot,
            startautorotation();
          );
        ,

          set(forceAutorotationFromPluginUnload, false);
          if(action['autorotationatstart'],
            set(forceAutorotationFromPluginUnload, true);
          );
          if(action['autotouratstart'],
            set(forceAutorotationFromPluginUnload, true);
          );
          if(forceAutorotationFromPluginUnload,
            if(tour_autorotation_openatstartplugin == 1,
              if((tour_autorotation_pauseplugin LE 0) AND (tour_autorotation_pausecounter LE 0),
                startautorotation();
              );
            );
          );
        );
      );
    );
  </action>
  <events name="autorotation_events" onnewpano="if(tour_autorotation_pauseplugin LE 0,resumeautorotation(forceresume););" ongyroscopeon="pauseautorotation(forceplugin);" ongyroscopeoff="resumeautorotation(forceplugin);" keep="true"/>


  <!-- AUTOTOUR -->

  <krpano useautotourdelay="true" autotourdelay="10" autotourHorizontalStartValue="0" />
  <action name="startautotour">
    set(tour_autotourenabled, true);
startautorotation();


    events.dispatch(onstartautotour);


  </action>
  <action name="resetautotourvariables">
    stopautotourtimer();
    delayedcall(autotour_call_id, get(autotourdelay), autotourtimer);
  </action>
  <action name="delayedcallAutotourPartial">
    sub(tempPosition, get(view.hlookat), get(autotourHorizontalStartValue));
    Math.ceil(tempPosition);
    Math.abs(tempPosition);
    if(borderCounter == 0 AND tempPosition LT previousStep,

      inc(borderCounter);
      Math.abs(firstStep, get(previousStep));
      sub(firstStepTest, get(previousStep), get(firstStep));
      set(firstStepKeep, get(firstStepTest));
      Math.abs(firstBorderSize, get(previousStep));
      add(totalPartialSize, get(firstBorderSize));
    );
    if(borderCounter GE 1,
      if(firstBorderSize != 0,
        sub(firstStepTest, get(previousStep), get(firstStep));
        Math.abs(firstStepTest, get(firstStepTest));
        if(firstStepTest LT firstStepKeep,

          add(totalPartialSize, get(firstBorderSize));
          set(firstBorderSize, 0);
        );
        set(firstStepKeep, get(firstStepTest));
      ,
        if(tempPosition LT previousStep,

          inc(borderCounter);
          Math.abs(secondBorderSize, get(previousStep));
          add(totalPartialSize, get(secondBorderSize));
        );
      );
    );
    set(previousStep, get(tempPosition));
    if(borderCounter GE 2 AND totalPartialSize GT panoramaHorizontalSize,
      delete(previousStep, panoramaHorizontalSize, totalPartialSize, firstBorderSize, secondBorderSize, firstStep, firstStepTest, firstStepKeep, borderCounter);
      autotourtimer();
    ,
      delayedcall(autotour_call_id, 0.5, delayedcallAutotourPartial);
    );
  </action>
  <action name="delayedcallAutotourFull360">
    sub(tempPosition, get(view.hlookat), get(autotourHorizontalStartValue));
    mod(tempPositionMod, get(tempPosition), 360);
    Math.ceil(tempPosition);
    Math.ceil(tempPositionMod);
    if(tempPositionMod == tempPosition,
      delayedcall(autotour_call_id, 0.5, delayedcallAutotourFull360);
    ,
      autotourtimer();
    );
  </action>
  <action name="stopautotour">
    set(tour_autotourenabled, false);
    stopautotourtimer();
stopautorotation();


    events.dispatch(onstopautotour);
  </action>
  <action name="autotourtimer">
    if(tour_autotourenabled,
      if(tour_autorotateenabled,
        if(autorotate.enabled OR useautotourdelay == true,
          stopautotour();loadNextScene();

          startautotour();
        );
      );
    );
  </action>
  <action name="stopautotourtimer">
    stopdelayedcall(autotour_call_id);
  </action>
  <events name="autotourevents" 
    onnewpano="autotouronnewpanoaction();" 
    onmouseup="autotouronuseraction(true);" 
    onmousedown="autotouronuseraction(false);" 
    onkeyup="autotouronuseraction(true);" 
    keep="true" />
  <action name="autotouronnewpanoaction">
    if(tour_autotourenabled, resetautotourvariables(););
  </action>
  <action name="autotouronuseraction">
    if(tour_autotourenabled, if(%1, resetautotourvariables();, stopautotourtimer();););
  </action>
  <events name="autotourstartevents" onTourStart="autotouratstart();" keep="true" />
  <action name="autotouratstart">
    if(norotation === null, if(noautotour === null, startautotour();););
    set(events[autotourstartevents].keep, false);
  </action>



  <krpano tour_deeplinkingvars=""/>
  <action name="computeDeepLinkingURL">
    txtadd(tour_deeplinkingvars, "s=", get(xml.scene));
    set(viewhlookat, get(view.hlookat));roundval(viewhlookat, 4);
    mod(viewhlookat, 360);
    if (viewhlookat GT 180,
      sub(viewhlookat, 360);
     ,
      if (viewhlookat LT -180, add(viewhlookat, 360));
    );
    set(viewvlookat, get(view.vlookat));roundval(viewvlookat, 4);
    set(viewfov, get(view.fov));roundval(viewfov, 4);
    txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;h=", get(viewhlookat));
    txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;v=", get(viewvlookat));
    txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;f=", get(viewfov));
    if (%1 !== null,if (%1, txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;skipintro");););
    if (%2 !== null,if (%2, txtadd(tour_deeplinkingvars, get(tour_deeplinkingvars), "&amp;norotation");););

  </action>


  <!-- Spot animation management -->
  <action name="animate">
    if (tour_stopsequence == false,
      if (stopspotsequence == false,
        txtadd(delayedname, %1, 'delay');
        if(hotspot[%1].loaded,
          inc(hotspot[%1].frame,1,get(hotspot[%1].lastframe),0);
          mul(hotspot[%1].ypos,get(hotspot[%1].frame),get(hotspot[%1].frameheight));
          txtadd(hotspot[%1].crop,'0|',get(hotspot[%1].ypos),'|',get(hotspot[%1].framewidth),'|',get(hotspot[%1].frameheight));
        );
        delayedcall(get(delayedname),%2,animate(%1,%2));
      );
    );
  </action>
  <action name="startspotanimation">
    set(tour_stopsequence, false);
    set(stopspotsequence , false);
    animate(get(name), %1);
  </action>
  <action name="stopspotanimation">
    set(hotspot[%1].stopspotsequence, true);
    txtadd(delayedname, %1, 'delay');
    stopdelayedcall(get(delayedname));
  </action>
  <action name="interruptAnimation">
    if(tour_stopsequence == false,
      set(tour_stopsequence, true);

    );
  </action>

  <!-- Disable the default fullscreen mode as it does a fullscreen only on the viewer not "on the tour" -->
  <contextmenu fullscreen="false" versioninfo="false" />

  <!-- Tooltips management -->
<!-- Tooltip Management -->
<krpano tooltipCurrentTextfieldLayer="panotourTooltipDefaultText" coretooltipmess=""/>

<events name="showHideTooltipEvents" onremovepano="hideTooltip();" keep="true" />

<action name="showTooltip">
  if (tooltip !== null,
	getmessage(currentTooltipText, get(tooltip));
	if (%2 == null,
		set(tooltipCurrentTextfieldLayer, "panotourTooltipDefaultText");
	,
		set(tooltipCurrentTextfieldLayer, %2);
	);
  );
</action>
<action name="hideTooltip">
	set(layer[get(tooltipCurrentTextfieldLayer)].visible, false);
	set(layer[get(tooltipCurrentTextfieldLayer)].html, '');
</action>

<action name="tooltipTextSettingsUpdate">
	if(get(tooltipCurrentTextfieldLayer) != "",

		set(layer[get(tooltipCurrentTextfieldLayer)].align, "center");
		if (%2 == null,
			set(layer[get(tooltipCurrentTextfieldLayer)].edge, "bottom");
		,
			set(layer[get(tooltipCurrentTextfieldLayer)].edge, %2);
		);
		if (%3 != null,
			set(layer[get(tooltipCurrentTextfieldLayer)].wordwrap, true);
			set(layer[get(tooltipCurrentTextfieldLayer)].width, %3);
		);
		if (%4 != null,
			set(layer[get(tooltipCurrentTextfieldLayer)].xoffset, %4);
		);
		if (%5 != null,
			set(layer[get(tooltipCurrentTextfieldLayer)].yoffset, %5);
		);
		set(layer[get(tooltipCurrentTextfieldLayer)].zorder, 99);
	);
</action>

<action name="showPermanentTooltip">
	if (tooltip !== null,
		getmessage(currentTooltipText, get(tooltip));
		ifnot (currentTooltipText == "",
			txtadd(permanentTooltipForSpot, get(tooltip), '_permanent');
			set(activateUsePermanentTooltip, false);
			if(%1 == "std",
				if(device.desktop,
					set(activateUsePermanentTooltip, true);
				);
			,
				if(%1 == "touch",
					if(device.tablet OR device.mobile,
						set(activateUsePermanentTooltip, true);
					);
				,
					set(activateUsePermanentTooltip, true);
				);
			);
			if(activateUsePermanentTooltip,
				addlayer(get(permanentTooltipForSpot));
				txtadd(plugin[get(permanentTooltipForSpot)].parent, 'hotspot[', get(name), ']');
				if (%2 == null,
					if(rotate,
						sub(newRotate, 0, get(rotate));
						if(rotate GE 0 AND rotate LT 45 OR rotate GE 315 AND rotate LT 360,
							set(plugin[get(permanentTooltipForSpot)].rotate,get(newRotate));
							set(plugin[get(permanentTooltipForSpot)].align,bottom);
						,
							if(rotate GE 45 AND rotate LT 135,
								set(plugin[get(permanentTooltipForSpot)].rotate,get(newRotate));
								set(plugin[get(permanentTooltipForSpot)].align,right);
							,
								if(rotate GE 135 AND rotate LT 225,
									set(plugin[get(permanentTooltipForSpot)].rotate,get(newRotate));
									set(plugin[get(permanentTooltipForSpot)].align,top);
								,
									set(plugin[get(permanentTooltipForSpot)].rotate,get(newRotate));
									set(plugin[get(permanentTooltipForSpot)].align,left);
								);
							);
						);
					,
						set(plugin[get(permanentTooltipForSpot)].align,bottom);
					);
					set(plugin[get(permanentTooltipForSpot)].edge,top);
				,

					set(plugin[get(permanentTooltipForSpot)].align,%2);
					set(plugin[get(permanentTooltipForSpot)].edge,%3);
				);
				set(plugin[get(permanentTooltipForSpot)].enabled,false);
				set(plugin[get(permanentTooltipForSpot)].capture,false);
				set(layer[get(permanentTooltipForSpot)].visible, true);

				set(plugin[get(permanentTooltipForSpot)].type, 'text');
				set(plugin[get(permanentTooltipForSpot)].bg,false);
				set(plugin[get(permanentTooltipForSpot)].bgborder,0);
				set(plugin[get(permanentTooltipForSpot)].txtshadow,'1.0 1.0 4.0 0x000000 1');
				set(plugin[get(permanentTooltipForSpot)].css,'color:#ffffff;font-family:Arial;font-weight:bold;font-size:14px;text-align:center;');
				set(plugin[get(permanentTooltipForSpot)].interactivecontent, false);
				set(plugin[get(permanentTooltipForSpot)].zorder,0);
				set(plugin[get(permanentTooltipForSpot)].padding,2);

				set(tooltipHtmlText, get(currentTooltipText));
				escape(tooltipHtmlText);
				set(layer[get(permanentTooltipForSpot)].html, get(tooltipHtmlText));
			);
		);
	);
</action>

<action name="updatePermanentTooltip">
	for(set(hsi, 0), hsi LT hotspot.count, inc(hsi),
		if(hotspot[get(hsi)].tooltip !== NULL AND hotspot[get(hsi)].tooltip != "",
			txtadd(permTooltipName, get(hotspot[get(hsi)].tooltip), '_permanent');
			if(permTooltipName,
				getmessage(changeTooltipTxt, get(hotspot[get(hsi)].tooltip));
				escape(changeTooltipTxt);
				set(layer[get(permTooltipName)].html, get(changeTooltipTxt));
			);
		);
	);
</action>

<events name="permanentTooltipEvents" keep="true" changetourlanguage="updatePermanentTooltip()" />



<!-- Default HTML5 tooltip style -->
<layer name="panotourTooltipDefaultText"
	keep="true"
	enabled="false"
	capture="false"
	type="text"
	align="center"
	bg="false"
	bgborder="0"
	txtshadow="1.0 1.0 4.0 0x000000 1"
	css="color:#ffffff;font-family:Arial;font-weight:bold;font-size:14px;text-align:left;"
	edge="bottom"
	interactivecontent="false"
	zorder="0"
	padding="2"
	xoffset="0"
	yoffset="0"
	visible="false"
	html=""
/>





	<!-- WebVR plugin -->


	<plugin name="webvr" devices="html5" keep="true"
		url="%FIRSTXML%/graphics/webvr.js"
		onloaded="copy(webvr, plugin[webvr]);"
		mousespeed="0.00125"
		multireslock="true"
    	fullscreen_mirroring="true"
		mobilevr_support="true"
		worldscale="1.0"
		oversampling="1.0"
		mobilevr_ipd="63.5"
		mobilevr_screensize="auto"
		mobilevr_lens_fov="96.0"
		mobilevr_lens_dist="0.60"
		mobilevr_lens_dist2="1.000|0.000|0.000|0.000"
		mobilevr_lens_ca="0.000"
		mobilevr_lens_vign="100"
		mobilevr_lens_overlap="1.0"
		mobilevr_wakelock="true"
		mobilevr_sensor_mode="3"
		mobilevr_autocalibration="false"
		mobilevr_touch_support="false"
		mobilevr_orientationlock="true"
		mobilevr_fake_support="false"
		vr_cursor="hotspot[vr_cursor]"
		vr_cursor_enabled="true"
		vr_cursor_onover="if(handcursor, tween(hotspot[vr_cursor].scale,0.4,0.1); vr_auto_click(get(vr_timeout)); );"
		vr_cursor_onout="tween(hotspot[vr_cursor].scale,0.3,0.1);"
		onavailable="webvr_onavailable();"
		onunavailable="webvr_onunavailable();"
		onunknowndevice="webvr_onunknowndevice();"
		onentervr="webvr_onentervr();webvr_portrait_mode_check(true);"
		onexitvr="webvr_onexitvr();"
		/>


	<vrheadsets>
		<headset name="cb1" caption="Cardboard 1"   fov="96.0"  dist="0.60" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.00" />
		<headset name="cb2" caption="Cardboard 2"   fov="96.0"  dist="1.00" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.10" />
		<headset name="gvr" caption="GearVR"        fov="112.0" dist="0.95" dist2="1|0|0|0" ca="0.090" vig="100" overlap="1.00" />
		<headset name="one" caption="VR ONE"        fov="109.9" dist="0.00" dist2="1.139|0.093|0.018|0.207" ca="0.090" vig="35" overlap="1.00" />
		<headset name="hom" caption="HOMiDO"        fov="101.0" dist="1.10" dist2="1|0|0|0" ca="0.075" vig="100" overlap="1.00" />
		<headset name="ccr" caption="ColorCross VR" fov="70.0"  dist="0.65" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.00" />
		<headset name="nod" caption="No Distortion" fov="96.0"  dist="0.00" dist2="1|0|0|0" ca="0.000" vig="100" overlap="1.00" />
	</vrheadsets>

	<action name="vr_tour_start">
		ifnot (tour_firststartactiondone,
			events.dispatch(onTourStart);
			set(tour_firststartactiondone, true);
		);
	</action>

	<hotspot name="vr_cursor" keep="true"
		url="%FIRSTXML%/graphics/webvr_cursor.png"
		crop="0|0|80|80"
		visible="false"
		enabled="false"
		distorted="true"
		scale="0.3"
		depth="1000"
		/>


	<layer name="vr_rotate_device_required" keep="true" devices="mobile"
		url="%FIRSTXML%/graphics/rotate_device.png" width="80%" height="prop"
		align="center" edge="center"
		autoalpha="true" alpha="0.0"
		enabled="false"
		/>


	<action name="vr_auto_click">
		if(webvr.isenabled,
			if(%1 != null, set(vr_aclk_timeout, %1), set(vr_aclk_timeout, 2000));
			copy(vr_aclk_t1, timertick);
			set(vr_aclk_waiting, true);
			copy(webvr.vr_aclk_hotspot, name);
			set(hotspot[vr_cursor].crop,'0|0|80|80');

			asyncloop(vr_aclk_waiting AND webvr.vr_aclk_hotspot == name,
				sub(dt, timertick,vr_aclk_t1);
				if(!hovering,
					set(vr_aclk_waiting, false);
					set(hotspot[vr_cursor].crop,'0|0|80|80');
				,
					div(f, dt, vr_aclk_timeout);
					mul(f, 16);
					roundval(f);
					Math.min(f, 16);
					mul(f, 80);
					txtadd(hotspot[vr_cursor].crop,get(f),'|0|80|80');

					sub(dt, 100);
					if(dt GT vr_aclk_timeout,
						set(vr_aclk_waiting,false);
						set(hotspot[vr_cursor].crop,'0|0|80|80');

						onclick();

						hotspot[vr_cursor].onout();
					);
				);
			);
		);
	</action>


	<events name="webvr_events" devices="html5" keep="true"
		onkeydown="if(webvr AND webvr.isenabled AND keycode==32, webvr.resetSensor(0) );"
		onmousedown="if(webvr AND webvr.isenabled, webvr_showbuttons() );"
		onresize.mobile="webvr_portrait_mode_check();"
		onexitfullscreen="vr_setup_close(false);"
		/>


	<action name="webvr_onavailable">
		if(nofullspherepanoavailable,
			webvr_onunavailable();
		,

			set(webvr.worldscale,1.0);
			webvr.loadsettings();
			set(layer[webvr_enterbutton].onclick, webvr.enterVR();set(visible, false); );
		);
	</action>


	<action name="webvr_onunknowndevice">
		if(webvr.isfake AND device.desktop AND webvr.havesettings == false,
			set(webvr.mobilevr_lens_overlap, 1.0);
			set(webvr.mobilevr_lens_fov, 96.0);
			set(webvr.mobilevr_lens_dist, 0.0);
			set(webvr.mobilevr_lens_dist2, '1|0|0|0');
			set(webvr.mobilevr_lens_ca, 0.0);
			set(webvr.mobilevr_lens_vign, 100);
		  ,
			set(webvr.ask_user_for_screensize,true);
		  );
	</action>


	<action name="webvr_onunavailable">

		delayedcall(5.0, js(accessStdVr(get(xml.scene),get(tour_language))););

		set(events[webvr_events].name, null);
		removelayer(webvr_button_text);
		removelayer(webvr_button_enter);
		removelayer(webvr_button_image);
		removelayer(webvr_enterbutton);
		removelayer(webvr_exitbutton);
		removelayer(webvr_setupbutton);
		removehotspot(vr_cursor);
		removeplugin(WebVR);
		delete(webvr);
		set(display.hotspotrenderer,'');

		addlayer(webvr_button_unavailable);
		set(layer[webvr_button_unavailable].type, 'text');
		getmessage(vr_setup_ct_message, "vr_setup_unavailable");
		set(layer[webvr_button_unavailable].html, get(vr_setup_ct_message));
		set(layer[webvr_button_unavailable].bg, false);
		set(layer[webvr_button_unavailable].align, "center");
		set(layer[webvr_button_unavailable].edge, "center");
		set(layer[webvr_button_unavailable].txtshadow, '1.0 1.0 4.0 0xd5d5d5 1.0');
		set(layer[webvr_button_unavailable].onclick, js(accessStdVr(get(xml.scene),get(tour_language))););
		set(layer[webvr_button_unavailable].onloaded, if(device.mobile,set(css, 'color:#ffffff;font-size:24px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;text-align:center;');,set(css, 'color:#ffffff;font-size:32px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;text-align:center;')));"
	</action>

	<action name="webvr_onentervr">
		vr_tour_start();

		set(layer[webvr_enterbutton].visible, false);


		if(webvr.ismobilevr == true AND !webvr.isfake AND webvr.ask_user_for_screensize == true AND webvr.mobilevr_screensize == 'auto',
			set(webvr.ask_user_for_screensize, false);
			vr_setup_advanced();
		);
	</action>

	<action name="webvr_onexitvr">
		stopdelayedcall(vr_button_fadeout);
		set(layer[webvr_enterbutton].visible,true);
		set(layer[webvr_exitbutton].alpha,0);
		set(layer[webvr_setupbutton].alpha,0);
		set(layer[vr_rotate_device_required].alpha,0);


		js(accessStdVr(get(xml.scene),get(tour_language)));
	</action>


	<action name="webvr_portrait_mode_check">
		if(device.mobile AND webvr.isenabled,
			div(aspect, stagewidth, stageheight);
			if(aspect != lastaspect OR '%1' == 'true',
				copy(lastaspect, aspect);
				if(stagewidth GT stageheight,

					set(display.stereo, true);
					set(webvr.mobilevr_sensor_mode, 3);
					webvr.update();
					tween(layer[vr_rotate_device_required].alpha, 0.0, 0.0);
				,

					set(display.stereo, false);
					set(webvr.mobilevr_sensor_mode, 1);
					webvr.update();
					tween(layer[vr_rotate_device_required].alpha, 1.0);
					delayedcall(3.0, tween(layer[vr_rotate_device_required].alpha, 0.0, 1.0););
				);
			);
		,
			set(lastaspect, 0);
		);
	</action>


	<layer name="webvr_enterbutton" keep="true" vr="false"
		type="container" width="100%" height="100%" align="topleft"
		bgcolor="0xffffff"
		bgalpha="0.5"
		bgborder="0"
		bgroundedge="0"
		bgshadow=""
		bgcapture="true" enabled="true"
		>

		<layer name="webvr_button_text"
			type="text"
			html=""
			bg="false"
			align="center"
			edge="bottom"
			y="-100"
			txtshadow="1.0 1.0 4.0 0xd5d5d5 1.0"
			enabled="false"
			onloaded="getmessage(html, 'project_title');if(device.mobile,set(css, 'color:#ffffff;font-size:24px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;');,set(css, 'color:#ffffff;font-size:32px;font-family:Arial,Helvetica,sans-serif;font-weight:bold;'));"
			/>

		<layer name="webvr_button_enter"
			align="center" url="%FIRSTXML%/graphics/webvr_toggle.png" crop="0|0|100|63"
			width="100" height="63"
			alpha="1"
			y="-40"
			enabled="false" />

		<layer name="webvr_button_image"
			align="center" url="%FIRSTXML%/thumbnail.jpg"
			y="20" edge="top"
			width="240" height="120"
			alpha="0.8"
			enabled="false" />
	</layer>

	<layer name="webvr_exitbutton" keep="true"
		url="%FIRSTXML%/graphics/webvr_toggle.png" crop="0|63|100|63" width="100" height="63"
		onclick="webvr.exitVR();"
		align="top" y="24"
		alpha="0"
		/>

	<layer name="webvr_setupbutton" keep="true"
		url="%FIRSTXML%/graphics/webvr_settings.png" width="64" height="64"
		onclick="vr_setup_simple();"
		alpha="0"
		align="bottom" y="24"
		/>

	<action name="webvr_showbuttons">
		stopdelayedcall(vr_button_fadeout);
		if(webvr.ismobilevr,
			tween(layer[webvr_exitbutton].alpha|layer[webvr_setupbutton].alpha, 1.0|1.0, 0.25);
		,
			tween(layer[webvr_exitbutton].alpha, 1.0, 0.25);
		);
		delayedcall(vr_button_fadeout,3,
			tween(layer[webvr_exitbutton].alpha|layer[webvr_setupbutton].alpha, 0.0|0.0, 1.0);
		);
	</action>

	<!-- WebVR plugin setup -->
	<action name="vr_setup">
		vr_setup_close(false);

		if(webvr.vrsetup === null, def(webvr.vrsetup, object); );
		copy(vrs, webvr.vrsetup);

		set(webvr.vr_cursor_enabled, false);

		tween(layer[webvr_exitbutton].alpha,0);
		tween(layer[webvr_setupbutton].alpha,0);

		addlayer(vr_setup_bg);
		set(layer[vr_setup_bg].type, container);
		set(layer[vr_setup_bg].bgcolor, 0x000000);
		set(layer[vr_setup_bg].bgalpha, 0.5);
		set(layer[vr_setup_bg].bgcapture, true);
		set(layer[vr_setup_bg].handcursor, false);
		set(layer[vr_setup_bg].align, lefttop);
		set(layer[vr_setup_bg].width, 100%);
		set(layer[vr_setup_bg].height, 100%);
		set(layer[vr_setup_bg].zorder, 99999);


		copy(i_screensize, webvr.mobilevr_screensize);
		if(i_screensize == 'auto', copy(i_screensize, webvr.devicesize));
		if(i_screensize LE 0, set(i_screensize, 5.0));
		roundval(i_screensize, 1);
		txtadd(i_screensize, ' inch');

		copy(i_ipd, webvr.mobilevr_ipd);
		roundval(i_ipd, 1);
		txtadd(i_ipd, ' mm');

		copy(i_fov, webvr.mobilevr_lens_fov);
		roundval(i_fov, 1);

		copy(i_dist, webvr.mobilevr_lens_dist);
		roundval(i_dist, 2);

		copy(i_dist2, webvr.mobilevr_lens_dist2);
		txtsplit(i_dist2, '|', vrs.i_dist2_k1, vrs.i_dist2_k2, vrs.i_dist2_k3, vrs.i_dist2_k4);
		mul(vrs.i_dist2_k1,1);
		mul(vrs.i_dist2_k2,10);
		mul(vrs.i_dist2_k3,10);
		mul(vrs.i_dist2_k4,10);
		roundval(vrs.i_dist2_k1,3);
		roundval(vrs.i_dist2_k2,3);
		roundval(vrs.i_dist2_k3,3);
		roundval(vrs.i_dist2_k4,3);

		copy(i_vig, webvr.mobilevr_lens_vign);
		roundval(i_vig, 0);

		copy(i_overlap, webvr.mobilevr_lens_overlap);
		roundval(i_overlap, 2);

		copy(i_ca, webvr.mobilevr_lens_ca);
		roundval(i_ca, 3);

		set(i_headset, 'Custom');

		for(set(vrheadi,0), vrheadi LT vrheadsets.headset.count, inc(vrheadi),
			copy(hs, vrheadsets.headset[get(vrheadi)]);
			if(i_fov == hs.fov AND i_dist == hs.dist AND i_vig == hs.vig AND i_overlap == hs.overlap AND i_dist2 == hs.dist2 AND i_ca == hs.ca,
				copy(i_headset, hs.caption);
			);
		);


		set(known_size, true);
		set(sizcol, #FFFFFF);
		copy(i_devicename, webvr.devicename);
		if(i_devicename == 'Unknown',
			if(webvr.mobilevr_screensize == 'auto',
				set(sizcol, #AA0000);
				set(known_size, false);
			,
				set(i_devicename, 'Custom');
			);
		);
	</action>

	<action name="vr_setup_simple">
		vr_setup();
		copy(vrs, webvr.vrsetup);

		set(layer[vr_setup_m1].visible, false);
		set(layer[vr_setup_m2].visible, false);
		set(layer[vr_setup_m3].visible, false);

		addlayer(vr_setup_m4);
		set(layer[vr_setup_m4].type, container);
		set(layer[vr_setup_m4].parent, vr_setup_bg);
		set(layer[vr_setup_m4].align, lefttop);
		set(layer[vr_setup_m4].width, 100%);
		set(layer[vr_setup_m4].height, 100%);
		set(layer[vr_setup_m4].visible, true);

		set(vrs.vr_setup_text_parent, 'vr_setup_m4');
		vr_setup_createtext(vr_setup_hmd0, '', center, center, 0, -140, #FFFFFF, false);
		vr_setup_createimage(vr_setup_hmd4, get(i_headset), center, center, 0, -20, #FFFFFF, true, vr_setup_select('headset_simple'), , vr_setup_save());
		vr_setup_createtext(vr_setup_hmd2, get(i_headset), center, center, 0, 100, #FFFFFF, false);

		vr_setup_createtext(vr_setup_advanced, '', center, center, 0, 140, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_advanced());

		vr_setup_createbutton(vr_setup_btn1, '&#60;', left, left, 5%, 0, #FFFFFF, true, null);
		vr_setup_createbutton(vr_setup_btn2, '&#62;', right, right, 5%, 0, #FFFFFF, true, null);

		vr_setup_select('headset_simple', true);
	</action>

	<action name="vr_setup_advanced">
		vr_setup();
		copy(vrs, webvr.vrsetup);
		set(layer[vr_setup_m4].visible, false);


		addlayer(vr_setup_m1);
		set(layer[vr_setup_m1].type, container);
		set(layer[vr_setup_m1].parent, vr_setup_bg);
		set(layer[vr_setup_m1].align, lefttop);
		set(layer[vr_setup_m1].width, 100%);
		set(layer[vr_setup_m1].height, 100%);
		set(layer[vr_setup_m1].visible, true);


		addlayer(vr_setup_m3);
		set(layer[vr_setup_m3].type, container);
		set(layer[vr_setup_m3].parent, vr_setup_bg);
		set(layer[vr_setup_m3].align, lefttop);
		set(layer[vr_setup_m3].width, 100%);
		set(layer[vr_setup_m3].height, 100%);
		set(layer[vr_setup_m3].visible, false);


		addlayer(vr_setup_m2);
		set(layer[vr_setup_m2].type, container);
		set(layer[vr_setup_m2].parent, vr_setup_bg);
		set(layer[vr_setup_m2].align, lefttop);
		set(layer[vr_setup_m2].width, 100%);
		set(layer[vr_setup_m2].height, 100%);
		set(layer[vr_setup_m2].visible, false);


		set(vrs.vr_setup_text_parent, 'vr_setup_m1');
		vr_setup_createtext(vr_setup_title, '', center, center, 0, -160, #FFFFFF, false);

		vr_setup_createtext(vr_setup_dvn1, '', center, right, 0, -115, #FFFFFF, true, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_dvn2, get(i_devicename), center, left, 0, -115, get(sizcol), true, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_siz1, '', center, right, 0, -85, #FFFFFF, true, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_siz2, get(i_screensize), center, left, 0, -85, get(sizcol), true, vr_setup_select('screen'));

		vr_setup_createtext(vr_setup_ipd1, '', center, right, 0, -40, #FFFFFF, true, vr_setup_select('ipd'));
		vr_setup_createtext(vr_setup_ipd2, get(i_ipd), center, left, 0, -40, #FFFFFF, true, vr_setup_select('ipd'));

		vr_setup_createtext(vr_setup_hmd1, '', center, right, 0, +5, #FFFFFF, true, vr_setup_select('headset'));
		vr_setup_createtext(vr_setup_hmd2, get(i_headset), center, left, 0, +5, #FFFFFF, true, vr_setup_select('headset'));

		vr_setup_createtext(vr_setup_hmd3, '', center, center, 0, +35, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_customize_headset());

		if(webvr.iswebvr == false,
			vr_setup_createtext(vr_setup_cal, '', center, center, 0, +80, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_calibration());
		);

		vr_setup_createtext(vr_setup_sav   , '', center, right, -20, +125, #00AA00, true, set(bg,true), set(bg,false), vr_setup_save());
		vr_setup_createtext(vr_setup_rst   , '', center, left , +20, +125, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_reset());
		vr_setup_createtext(vr_setup_simple, '', center, right, -20, +155, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_simple());
		vr_setup_createtext(vr_setup_cls   , '', center, left , +20, +155, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_close(true));


		vr_setup_createbutton(vr_setup_btn1, '&#60;', left, left, 5%, 0, #FFFFFF, true, null);
		vr_setup_createbutton(vr_setup_btn2, '&#62;', right, right, 5%, 0, #FFFFFF, true, null);


		set(vrs.vr_setup_text_parent, 'vr_setup_m3');
		vr_setup_createtext(vr_setup_m31, '', center, center, 0, -160, #FFFFFF, false);

		vr_setup_createtext(vr_setup_fov1, '', center, right, 0, -75, #FFFFFF, true, vr_setup_select('fov'));
		vr_setup_createtext(vr_setup_fov2, get(i_fov), center, left, 0, -75, #FFFFFF, true, vr_setup_select('fov'));
		vr_setup_createtext(vr_setup_dst1, '', center, right, 0, -40, #FFFFFF, true, vr_setup_select('dist'));
		vr_setup_createtext(vr_setup_dst2, get(i_dist), center, left, 0, -40, #FFFFFF, true, vr_setup_select('dist'));
		vr_setup_createtext(vr_setup_d2tx, '', center, right, 0, -5, #FFFFFF, true, vr_setup_select('dist2k1'));
		vr_setup_createtext(vr_setup_d2k1, get(vrs.i_dist2_k1), center, left, 0, -5, #FFFFFF, true, vr_setup_select('dist2k1'));
		vr_setup_createtext(vr_setup_d2k2, get(vrs.i_dist2_k2), center, left, +100, -5, #FFFFFF, true, vr_setup_select('dist2k2'));
		vr_setup_createtext(vr_setup_d2k3, get(vrs.i_dist2_k3), center, left, +200, -5, #FFFFFF, true, vr_setup_select('dist2k3'));
		vr_setup_createtext(vr_setup_d2k4, get(vrs.i_dist2_k4), center, left, +300, -5, #FFFFFF, true, vr_setup_select('dist2k4'));

		vr_setup_createtext(vr_setup_cac1, '', center, right, 0, +30, #FFFFFF, true, vr_setup_select('ca'));
		vr_setup_createtext(vr_setup_cac2, get(i_ca), center, left, 0, +30, #FFFFFF, true, vr_setup_select('ca'));
		vr_setup_createtext(vr_setup_vig1, '', center, right, 0, +65, #FFFFFF, true, vr_setup_select('vignette'));
		vr_setup_createtext(vr_setup_vig2, get(i_vig), center, left, 0, +65, #FFFFFF, true, vr_setup_select('vignette'));
		vr_setup_createtext(vr_setup_olp1, '', center, right, 0, +100, #FFFFFF, true, vr_setup_select('overlap'));
		vr_setup_createtext(vr_setup_olp2, get(i_overlap), center, left, 0, +100, #FFFFFF, true, vr_setup_select('overlap'));

		vr_setup_createtext(vr_setup_m35, '', center, center, 0, +160, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_close_sub_menus() );


		set(vrs.vr_setup_text_parent, 'vr_setup_m2');
		vr_setup_createtext(vr_setup_cb1, '', center, center, 0, -160, #FFFFFF, false);
		vr_setup_createtext(vr_setup_cb2, '', center, center, 0, -80, #FFFFFF, false, vr_setup_select('screen'));
		vr_setup_createtext(vr_setup_cb3, '', center, center, 0, +40, #00AA00, true, set(bg,true), set(bg,false), vr_setup_do_calibration());
		vr_setup_createtext(vr_setup_cb4, '', center, center, 0, +80, #FFFFFF, true, set(bg,true), set(bg,false), webvr.resetcalibration());
		vr_setup_createtext(vr_setup_cb5, '', center, center, 0, +160, #FFFFFF, true, set(bg,true), set(bg,false), vr_setup_close_sub_menus());

		vr_setup_createtext(vr_setup_cb6, '', center, center, 0, +120, #FFFFFF, false, null);
		vr_setup_createtext(vr_setup_cb7, '', center, center, 0, +120, #00AA00, false, null);
		vr_setup_createtext(vr_setup_cb8, '', center, center, 0, +120, #AA0000, false, null);
		set(layer[vr_setup_cb6].autoalpha, true);
		set(layer[vr_setup_cb7].autoalpha, true);
		set(layer[vr_setup_cb8].autoalpha, true);
		set(layer[vr_setup_cb6].alpha, 0.0);
		set(layer[vr_setup_cb7].alpha, 0.0);
		set(layer[vr_setup_cb8].alpha, 0.0);


		if(known_size == false,
			vr_setup_select('screen', true);
		,
			vr_setup_select('ipd', true);
		);
	</action>

	<action name="vr_setup_createtext">
		addlayer(%1);
		set(layer[%1].parent, get(webvr.vrsetup.vr_setup_text_parent));
		set(layer[%1].type, 'text');
		if(device.mobile,
			set(layer[%1].css, 'color:%7;font-size:24px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
		,
			set(layer[%1].css, 'color:%7;font-size:32px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
		);
		set(layer[%1].padding, 0 8);
		set(layer[%1].bgroundedge, 8);
		set(layer[%1].bg, false);
		set(layer[%1].bgcolor, 0xFFFFFF);
		set(layer[%1].bgalpha, 0.25);
		set(layer[%1].align, %3);
		set(layer[%1].edge, %4);
		set(layer[%1].x, %5);
		set(layer[%1].y, %6);

		if ('%2' == '',
			getmessage(vr_setup_ct_message, %1);
			set(layer[%1].html, get(vr_setup_ct_message));
		 ,
			set(layer[%1].html, %2);
		);

		set(layer[%1].enabled, %8);
		set(layer[%1].ondown, %9);
		set(layer[%1].onup, %10);
		set(layer[%1].onclick, %11);
	</action>

	<action name="vr_setup_createbutton">
		vr_setup_createtext(%1,%2,%3,%4,%5,%6,%7,%8,%9);
		if(device.mobile,
			set(layer[%1].css, 'vertical-align:middle;text-align:center;color:%7;font-size:42px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
			set(layer[%1].width, 54);
			set(layer[%1].height, 54);
		,
			set(layer[%1].css, 'vertical-align:middle;text-align:center;color:%7;font-size:48px;font-weight:bold;font-family:Arial,Helvetica,sans-serif;');
			set(layer[%1].width, 60);
			set(layer[%1].height, 60);
		);
		set(layer[%1].bg, true);
		set(layer[%1].padding, 0);
		set(layer[%1].bgroundedge, 8);
		set(layer[%1].vcenter, true);
	</action>

	<action name="vr_setup_createimage">
		addlayer(%1);
		set(layer[%1].parent, get(webvr.vrsetup.vr_setup_text_parent));
		set(hmd_headset, %2);
		txtreplace(hmd_headset, ' ', '');
		txtadd(imgurl, '%FIRSTXML%/graphics/', get(hmd_headset), '.png');
		set(layer[%1].url, get(imgurl));
		set(layer[%1].align, %3);
		set(layer[%1].edge, %4);
		set(layer[%1].x, %5);
		set(layer[%1].y, %6);
		set(layer[%1].width, 266);
		set(layer[%1].height, 174);
		set(layer[%1].vcenter, true);
		set(layer[%1].enabled, %8);
		set(layer[%1].ondown, %9);
		set(layer[%1].onup, %10);
		set(layer[%1].onclick, %11);
	</action>

	<action name="vr_setup_reset">

		set(webvr.mobilevr_screensize, 'auto');
		copy(i_screensize, webvr.devicesize);
		if(i_screensize LE 0, set(i_screensize, 5.0));
		roundval(i_screensize, 1);
		set(layer[vr_setup_dvn2].html, get(webvr.devicename));
		txtadd(layer[vr_setup_siz2].html, get(i_screensize), ' inch');

		set(webvr.mobilevr_ipd, 63.5);
		copy(i_ipd, webvr.mobilevr_ipd);
		roundval(i_ipd, 1);
		txtadd(layer[vr_setup_ipd2].html, get(i_ipd), ' mm');


		set(webvr.mobilevr_lens_fov, 100.0);
		set(webvr.mobilevr_lens_dist, 0.50);
		set(webvr.mobilevr_lens_dist2, 1.000|0.000|0.000|0.000);
		set(webvr.mobilevr_lens_vign, 100);
		set(webvr.mobilevr_lens_overlap, 1.00);
		set(webvr.mobilevr_lens_ca, 0.000);

		if(webvr.isfake AND device.desktop,
			vr_setup_change_headset(-1);
		,
			vr_setup_change_headset(1);
		);

		copy(vrs, webvr.vrsetup);
		vr_setup_select(get(vrs.var));
	</action>

	<action name="vr_setup_close">

		removelayer(vr_setup_bg, true);


		if(%1 == true,
			set(webvr.vr_cursor_enabled, true);
		);
	</action>

	<action name="vr_setup_save">
		webvr.saveSettings();
		vr_setup_close(true);
	</action>

	<action name="vr_setup_customize_headset">
		set(layer[vr_setup_m1].visible,false);
		set(layer[vr_setup_m2].visible,false);
		set(layer[vr_setup_m3].visible,true);

		set(layer[vr_setup_hmd1].parent, vr_setup_m3);
		set(layer[vr_setup_hmd2].parent, vr_setup_m3);
		set(layer[vr_setup_btn1].parent, vr_setup_m3);
		set(layer[vr_setup_btn2].parent, vr_setup_m3);

		set(layer[vr_setup_hmd1].y, -110);
		set(layer[vr_setup_hmd2].y, -110);

		copy(vrs, webvr.vrsetup);
		copy(vrs.old_selection, vrs.var);
		vr_setup_select('headset');
	</action>

	<action name="vr_setup_calibration">
		set(layer[vr_setup_m1].visible,false);
		set(layer[vr_setup_m2].visible,true);
	</action>

	<action name="vr_setup_close_sub_menus">
		set(layer[vr_setup_m1].visible,true);
		set(layer[vr_setup_m2].visible,false);
		set(layer[vr_setup_m3].visible,false);

		set(layer[vr_setup_hmd1].parent, vr_setup_m1);
		set(layer[vr_setup_hmd2].parent, vr_setup_m1);
		set(layer[vr_setup_btn1].parent, vr_setup_m1);
		set(layer[vr_setup_btn2].parent, vr_setup_m1);

		set(layer[vr_setup_hmd1].y, +5);
		set(layer[vr_setup_hmd2].y, +5);

		copy(vrs, webvr.vrsetup);
		if(vrs.old_selection,
			vr_setup_select(get(vrs.old_selection));
			delete(vrs.old_selection);
		);
	</action>

	<action name="vr_setup_update_dist2">
		copy(vrs, webvr.vrsetup);
		txtadd(webvr.mobilevr_lens_dist2, get(vrs.i_dist2_k1), '|', calc(vrs.i_dist2_k2/10.0), '|', calc(vrs.i_dist2_k3/10.0), '|', calc(vrs.i_dist2_k4/10.0));
		vr_setup_change_headset(0);
	</action>

	<action name="vr_setup_do_calibration">
		if(!webvr.isfake,
			tween(layer[vr_setup_cb6].alpha, 1.0, 0.1);
			tween(layer[vr_setup_cb7].alpha, 0.0, 0.1);
			tween(layer[vr_setup_cb8].alpha, 0.0, 0.1);
			webvr.calibrate(
				tween(layer[vr_setup_cb6].alpha, 0.0, 0.1);
				tween(layer[vr_setup_cb7].alpha, 1.0, 0.1);
				delayedcall(2.0, tween(layer[vr_setup_cb7].alpha, 0.0, 0.25));
			,
				tween(layer[vr_setup_cb6].alpha, 0.0, 0.1);
				tween(layer[vr_setup_cb8].alpha, 1.0, 0.1);
				delayedcall(2.0, tween(layer[vr_setup_cb8].alpha, 0.0, 0.25));
			);
		);
	</action>

	<action name="vr_setup_select">
		copy(vrs, webvr.vrsetup);

		set(layer[vr_setup_siz2].bg, false);
		set(layer[vr_setup_ipd2].bg, false);
		set(layer[vr_setup_hmd2].bg, false);
		set(layer[vr_setup_fov2].bg, false);
		set(layer[vr_setup_dst2].bg, false);
		set(layer[vr_setup_d2k1].bg, false);
		set(layer[vr_setup_d2k2].bg, false);
		set(layer[vr_setup_d2k3].bg, false);
		set(layer[vr_setup_d2k4].bg, false);
		set(layer[vr_setup_vig2].bg, false);
		set(layer[vr_setup_cac2].bg, false);
		set(layer[vr_setup_olp2].bg, false);

		set(layer[vr_setup_btn1].ondown, vr_setup_change_ondown(-1));
		set(layer[vr_setup_btn2].ondown, vr_setup_change_ondown(+1));

		set(vrs.setting, null);
		set(vrs.var, %1);
		set(vrs.var_value, null);
		set(vrs.var_callback, null);

		if(%1 == 'screen',
			set(vrs.setting, vr_setup_siz2);
			set(vrs.var_name, 'webvr.mobilevr_screensize');
			set(vrs.var_postfix, ' inch');
			copy(vrs.var_value, get(vrs.var_name));
			if(vrs.var_value == 'auto', set(vrs.var_value, 5.0));
			set(vrs.var_step, 0.1);
			set(vrs.var_min, 4);
			set(vrs.var_max, 10);
			set(vrs.var_round, 1);
			set(vrs.var_callback, vr_setup_change_screen());
		);

		if(%1 == 'ipd',
			set(vrs.setting, vr_setup_ipd2);
			set(vrs.var_name, 'webvr.mobilevr_ipd');
			set(vrs.var_postfix, ' mm');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.1);
			set(vrs.var_min, 40);
			set(vrs.var_max, 80);
			set(vrs.var_round, 1);
		);

		if(%1 == 'headset_simple',
			set(vrs.setting, vr_setup_hmd4);
			set(layer[vr_setup_btn1].ondown, vr_setup_change_headset(-1));
			set(layer[vr_setup_btn2].ondown, vr_setup_change_headset(+1));
		);

		if(%1 == 'headset',
			set(vrs.setting, vr_setup_hmd2);
			set(layer[vr_setup_btn1].ondown, vr_setup_change_headset(-1));
			set(layer[vr_setup_btn2].ondown, vr_setup_change_headset(+1));
		);

		if(%1 == 'fov',
			set(vrs.setting, vr_setup_fov2);
			set(vrs.var_name, 'webvr.mobilevr_lens_fov');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.1);
			set(vrs.var_min, 40);
			set(vrs.var_max, 179);
			set(vrs.var_round, 1);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'dist',
			set(vrs.setting, vr_setup_dst2);
			set(vrs.var_name, 'webvr.mobilevr_lens_dist');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.01);
			set(vrs.var_min, 0);
			set(vrs.var_max, 5);
			set(vrs.var_round, 2);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'dist2k1',
			set(vrs.setting, vr_setup_d2k1);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k1');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'dist2k2',
			set(vrs.setting, vr_setup_d2k2);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k2');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'dist2k3',
			set(vrs.setting, vr_setup_d2k3);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k3');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'dist2k4',
			set(vrs.setting, vr_setup_d2k4);
			set(vrs.var_name, 'webvr.vrsetup.i_dist2_k4');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -9);
			set(vrs.var_max, +9);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_update_dist2());
		);

		if(%1 == 'vignette',
			set(vrs.setting, vr_setup_vig2);
			set(vrs.var_name, 'webvr.mobilevr_lens_vign');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 1);
			set(vrs.var_min, 0);
			set(vrs.var_max, 100);
			set(vrs.var_round, 0);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'ca',
			set(vrs.setting, vr_setup_cac2);
			set(vrs.var_name, 'webvr.mobilevr_lens_ca');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.001);
			set(vrs.var_min, -1.0);
			set(vrs.var_max, +1.0);
			set(vrs.var_round, 3);
			set(vrs.var_callback, vr_setup_change_headset(0));
		);

		if(%1 == 'overlap',
			set(vrs.setting, vr_setup_olp2);
			set(vrs.var_name, 'webvr.mobilevr_lens_overlap');
			set(vrs.var_postfix, '');
			copy(vrs.var_value, get(vrs.var_name));
			set(vrs.var_step, 0.01);
			set(vrs.var_min, 0.5);
			set(vrs.var_max, 2.0);
			set(vrs.var_round, 2);
			set(vrs.var_callback, vr_setup_change_headset(0) );
		);

		if(vrs.setting != null,
			set(layer[get(vrs.setting)].bg, true);
			if(%2 == true,
				set(layer[vr_setup_btn1].y, get(layer[get(vrs.setting)].y));
				set(layer[vr_setup_btn2].y, get(layer[get(vrs.setting)].y));
			,
				tween(layer[vr_setup_btn1].y, get(layer[get(vrs.setting)].y));
				tween(layer[vr_setup_btn2].y, get(layer[get(vrs.setting)].y));
			);
		);
	</action>

	<action name="vr_setup_change_screen">
		set(layer[vr_setup_dvn2].html, 'Custom');
		if(device.mobile,
			set(layer[vr_setup_dvn2].css, 'color:#FFFFFF;font-size:24px;font-weight:bold;');
			set(layer[vr_setup_siz2].css, 'color:#FFFFFF;font-size:24px;font-weight:bold;');
		,
			set(layer[vr_setup_dvn2].css, 'color:#FFFFFF;font-size:32px;font-weight:bold;');
			set(layer[vr_setup_siz2].css, 'color:#FFFFFF;font-size:32px;font-weight:bold;');
		);
	</action>

	<action name="vr_setup_change_ondown">
		copy(t0,timertick);
		set(t1,0);
		asyncloop(pressed,
			copy(t2,timertick);
			sub(dt,t2,t1);
			if(dt GT 100,
				copy(t1,t2);
				sub(dt,t1,t0);
				div(dt,1000);
				Math.max(dt,1);
				mul(dt,%1);
				vr_setup_adjust(get(dt));
			);
		);
	</action>

	<action name="vr_setup_adjust">
		copy(vrs, webvr.vrsetup);
		if(vrs.setting != null,
			mul(change, vrs.var_step, %1);
			add(vrs.var_value, change);
			Math.max(vrs.var_value, vrs.var_min);
			Math.min(vrs.var_value, vrs.var_max);
			roundval(vrs.var_value, get(vrs.var_round));
			tween(get(vrs.var_name), get(vrs.var_value), 0.1);
			txtadd(layer[get(vrs.setting)].html, get(vrs.var_value), get(vrs.var_postfix));
			if(vrs.var_callback != null, vrs.var_callback());
		);
	</action>

	<action name="vr_setup_change_headset">
		set(i_headset, 'Custom');
		if(%1 != 0,
			copy(i_fov, webvr.mobilevr_lens_fov);
			roundval(i_fov, 1);
			copy(i_dist, webvr.mobilevr_lens_dist);
			roundval(i_dist, 2);
			copy(i_dist2, webvr.mobilevr_lens_dist2);
			copy(i_vig, webvr.mobilevr_lens_vign);
			roundval(i_vig, 0);
			copy(i_ca, webvr.mobilevr_lens_ca);
			roundval(i_ca, 3);
			copy(i_overlap, webvr.mobilevr_lens_overlap);
			roundval(i_overlap, 2);

			set(i_hsindex, -1);
			copy(i_hscount, vrheadsets.headset.count);
			for(set(vrheadj,0), vrheadj LT i_hscount, inc(vrheadj),
				copy(hs, vrheadsets.headset[get(vrheadj)]);
				if(i_fov == hs.fov AND i_dist == hs.dist AND i_vig == hs.vig AND i_overlap == hs.overlap AND i_dist2 == hs.dist2 AND i_ca == hs.ca,
					copy(i_hsindex, vrheadj);
					copy(i_headset, hs.caption);
				);
			);

			if(%1 GT 0,

				add(i_hsindex, 1);
				if(i_hsindex GE i_hscount, set(i_hsindex,0));
			,

				sub(i_hsindex, 1);
				if(i_hsindex LT 0, sub(i_hsindex,i_hscount,1));
			);

			copy(hs, vrheadsets.headset[get(i_hsindex)]);
			copy(i_headset, hs.caption);
			copy(i_fov, hs.fov);
			copy(i_dist, hs.dist);
			copy(i_dist2, hs.dist2);
			copy(i_vig, hs.vig);
			copy(i_ca, hs.ca);
			copy(i_overlap, hs.overlap);
		);

		copy(layer[vr_setup_hmd2].html, i_headset);
		txtreplace(hmd_headset, i_headset, ' ', '');
		txtadd(imgurl, '%FIRSTXML%/graphics/', get(hmd_headset), '.png');
		set(layer[vr_setup_hmd4].url, get(imgurl));
		if(%1 != 0,
			copy(webvr.mobilevr_lens_fov, i_fov);
			copy(webvr.mobilevr_lens_dist, i_dist);
			copy(webvr.mobilevr_lens_dist2, i_dist2);
			copy(webvr.mobilevr_lens_vign, i_vig);
			copy(webvr.mobilevr_lens_ca, i_ca);
			copy(webvr.mobilevr_lens_overlap, i_overlap);
			copy(layer[vr_setup_fov2].html, i_fov);
			copy(layer[vr_setup_dst2].html, i_dist);
			copy(layer[vr_setup_vig2].html, i_vig);
			copy(layer[vr_setup_olp2].html, i_overlap);
			copy(layer[vr_setup_cac2].html, i_ca);
			txtsplit(i_dist2, '|', i_dist2_k1, i_dist2_k2, i_dist2_k3, i_dist2_k4);
			mul(i_dist2_k1,1);
			mul(i_dist2_k2,10);
			mul(i_dist2_k3,10);
			mul(i_dist2_k4,10);
			roundval(i_dist2_k1,3);
			roundval(i_dist2_k2,3);
			roundval(i_dist2_k3,3);
			roundval(i_dist2_k4,3);
			copy(layer[vr_setup_d2k1].html, i_dist2_k1);
			copy(layer[vr_setup_d2k2].html, i_dist2_k2);
			copy(layer[vr_setup_d2k3].html, i_dist2_k3);
			copy(layer[vr_setup_d2k4].html, i_dist2_k4);
		);
	</action>



  <!-- Keyboard management 
  * use the keyboard +/- keys to zoom in/out
  * use the keyboard CTRL+0 keys to reset the default panorama view
  -->
  <control keycodesin="107,187" keycodesout="109,189" />
  <krpano tour_ctrlPressed="false"/>
  <events name="keycontrolZoomEvents" onkeydown="onKDZ" onkeyup="onKUZ" keep="true"/>
  <action name="onKDZ">if(keycode==17,set(tour_ctrlPressed,true);,if(tour_ctrlPressed==true,if(keycode==96,hideTooltip();lookto(get(panoview.h),get(panoview.v),get(panoview.fov)););););</action>
  <action name="onKUZ">if(keycode==17,set(tour_ctrlPressed,false););</action>

  <!-- Indicate if a scene is seen or not - dispatch an event if the state is changed -->
  <events name="sceneSeenEvents" onnewpano="changeSeenState" keep="true"/>
  <action name="changeSeenState">
    ifnot (scene[get(xml.scene)].seen,
      set(scene[get(xml.scene)].seen, true);
      events.dispatch(onSeenStateChanged);
    );
  </action>


  <cursors standard="default" dragging="grab" moving="move" />



</krpano>
